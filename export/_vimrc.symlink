" 2012-04-23
" maksimr .vimrc
"
" curl https://raw.githubusercontent.com/kana/vim-version-manager/master/bin/vvm | python - setup
" source ~/.vvm/etc/login
" vvm update_itself
" brew install python@3.8
" CFLAGS="-I$HOME/.rvm/rubies/$RUBY_VERSION/include/$RUBY_VERSION" LDFLAGS="-L$HOME/.rvm/rubies/$RUBY_VERSION/lib/" vvm use vimorg--v8.2.2825 --install --with-features=huge --enable-rubyinterp --enable-pythoninterp=yes --with-python-config-dir=/usr/lib/python2.7/config --enable-python3interp=yes --with-python3-config-dir=$(python3.8-config --configdir)

set nocp                 " Turn off vi compatibility mode
set noeb                 " Turn off error bell
set novb                 " Turn off visual error bell
set mouse=a              " Enable mouse
set bs=2                 " Enable backspace

set guifont=Terminus\ 14 " Set font (sudo apt-get install xfonts-terminus)
set t_Co=256             " Extended color support

set cursorline           " Highlight current line

set nu                   " Line number
set numberwidth=3        " Line number width

set lz
set guioptions=a
set guioptions-=T
set guioptions-=r        " Remove right scrollbar

"set spell                " Включить проверку арфографии

set nowrap               " Не переносить длинные строки ( set wrap - переносить )
set textwidth=0

set scrolloff=5          " Минимальное количество строк остающихся выше/ниже курсора. Помогает не терять контекст.
set scrolljump=5         " Минимальное количество строк при скроле
set incsearch            " Поиск по ходу набора
set ignorecase           " Игнорирует регистр при поиске
set smartcase            " Переписывает ignorecase когда осуществляется поиск включающий заглавные буквы

set laststatus=2         " Включение строки состояния внизу редактора
set statusline=%<%f%h%m%r%{fugitive#statusline()}\ %b\ %{&encoding}\ 0x\ \ %l,%c%V\ %P " Формат строки состояния ( использует расширение git-fugitive )


set smartindent          " Умный автоматический отступ (ai - обычный автоматичексий отступ)
set smarttab             " При нажатии в начале строки TAB добавляет отступ равный shiftwidth
set et                   " Включить автозамену таба на пробелы
set shiftwidth=2         " Устоновить ширину сдвига >
set listchars=tab:\··     " Показываем табы в начале строки точками
set listchars+=trail:\␣   " Показываем пробел в конце строки как ␣
set list
set formatoptions-=o     " dont continue comments when pushing o/O

set backup " Создавать резервные копии файлов
set backupdir^=~/.vim/backup  " Создавать резервные копии файлов в папке sessions или если ее нет то в том же каталоге
set dir^=~/.vim/sessions " Складываем swp файлы в sessions папку, а не в текущую (:h swap-file)

set wildmode=list:longest,full " Автодополнение на манер zsh в командной строке
set wildmenu
set wildignore+=.hg,.git,.svn  " Version control
set wildignore+=*.DS_Store     " OSX bullshit
set wildignore+=*.pyc          " Python byte code

" Workaround for problem with watch in karma and webpack
" https://github.com/karma-runner/karma/issues/199
set backupcopy=yes

let g:LycosaExplorerSuppressPythonWarning = 1

" Not open error window when netrw
" can not create folder
let g:netrw_use_errorwindow    = 0

" ↪ Символ, который будет показан перед перенесенной строкой
let &showbreak = nr2char(8618).' '

" Конфигурация расширений
let g:netrw_list_hide='\~$,\~\*$,\.swp$,\.svn'

" устанавливаем <Leader>-клавишу и <LocalLeader>
let mapleader=','
let maplocalleader=mapleader

set suffixesadd +=.js

"For example, we could adapt the includeexpr option to
"allow Vim to directly open up the appropriate file when we
"press gf on a class name by converting
"CamelCase words to dash-case:
"http://arjanvandergaag.nl/blog/navigating-project-files-with-vim.html
set includeexpr=substitute(substitute(v:fname,'^.','\\l\\0',''),'\\(\\u\\l\\+\\\|\\l\\+\\)\\(\\u\\)','\\l\\1-\\l\\2','g')

syn on                     " Включаем синтаксис
filetype plugin indent on  " Для некоторых типов файлов настройки отступов были перенесены из plugin в indent. Поэтому не забываем включить его

if system('uname -s') == "Darwin\n"
  set clipboard=unnamed " Копирование в сиситемный clipboard по нажатию на y(yank)
endif

let data_dir = has('nvim') ? stdpath('data') . '/site' : '~/.vim'
if empty(glob(data_dir . '/autoload/plug.vim'))
  silent execute '!curl -fLo '.data_dir.'/autoload/plug.vim --create-dirs  https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif

call plug#begin()
  Plug 'wincent/Command-T', { 'do': 'cd ruby/command-t/ext/command-t && { make clean; ruby extconf.rb && make }' }
  Plug 'kshenoy/vim-signature'
  Plug 'sjl/gundo.vim'
  Plug 'thisivan/vim-bufexplorer'
  Plug 'Lokaltog/vim-easymotion'
  Plug 'kana/vim-textobj-user'
  Plug 'glts/vim-textobj-comment'
  Plug 'junegunn/fzf'
  Plug 'Lokaltog/vim-powerline'
  Plug 'maksimr/Lucius2'
  Plug 'tpope/vim-fugitive'
  Plug 'airblade/vim-gitgutter'
  Plug 'mileszs/ack.vim'
  Plug 'vim-scripts/The-NERD-Commenter'
  Plug 'Raimondi/delimitMate'
  Plug 'mattn/emmet-vim'
  Plug 'tpope/vim-eunuch'
  Plug 'tpope/vim-surround'
  Plug 'terryma/vim-multiple-cursors'

  Plug 'maksimr/vim-jsbeautify'
  Plug 'einars/js-beautify'
  Plug 'metakirby5/codi.vim'

  Plug 'neoclide/coc.nvim', {'branch': 'release', 'do': ':CocInstall coc-json coc-tsserver'}
  " Make <CR> auto-select the first completion item and notify coc.nvim to
  " format on enter, <cr> could be remapped by other vim plugin
  inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm()
                              \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"
  " Use tab for trigger completion with characters ahead and navigate
  inoremap <silent><expr> <TAB>
        \ pumvisible() ? "\<C-n>" :
        \ <SID>check_back_space() ? "\<TAB>" :
        \ coc#refresh()
  inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"
  function! s:check_back_space() abort
    let col = col('.') - 1
    return !col || getline('.')[col - 1]  =~# '\s'
  endfunction
  nmap <silent> gd <Plug>(coc-definition)
  nmap <silent> gy <Plug>(coc-type-definition)
  nmap <silent> gi <Plug>(coc-implementation)
  nmap <silent> gr <Plug>(coc-references)

  Plug 'maksimr/vim-javascript'
  Plug 'rosstimson/bats.vim', { 'for': 'bat' }
  Plug 'guns/vim-clojure-static', {'for': 'clojure'}
  Plug 'tpope/vim-fireplace', {'for': 'clojure'}
  Plug 'kovisoft/slimv', {'for': 'clojure'}
  Plug 'vim-scripts/paredit.vim', {'for': 'clojure'}
  Plug 'kana/vim-vspec'
  Plug 'tmhedberg/matchit'
  Plug 'editorconfig/editorconfig-vim'
  Plug 'mhinz/vim-startify'
  Plug 'udalov/kotlin-vim'
  Plug 'tpope/vim-projectionist'
call plug#end()


colorscheme lucius

"  Bundle 'garbas/vim-snipmate'
" переопределение основной клавиши
" <esc> - Alt
let c='l'

while c <= 'z'
    exec "set <A-".c.">=\e".c
    exec "inoremap \e".c." <A-".c.">"
    let c = nr2char(1+char2nr(c))
endw

" CRAZYYYYYY <Alt>
imap <A-l> <Plug>snipMateNextOrTrigger
smap <A-l> <Plug>snipMateNextOrTrigger
set ttimeoutlen=50

"  Bundle 'kien/ctrlp.vim' <-----
" ctrlp_cmd - Команда которая будет вызвана по умолчанию
" 'CtrlPMixed' - искать все (внутри файлов, буферов и MRU файлах существующих
" в этот момент)
let g:ctrlp_cmd = 'CtrlPMixed'
let ctrlp_regexp = 1 "Включаем по умолчанию RegExp режим
let g:ctrlp_match_window_bottom = 1  " показывать окно совпадений внизу
let g:ctrlp_match_window_reversed = 0 " показывать максимальное совпадение сверху
let g:ctrlp_max_height = 10    " высота окна совпадений

let g:ctrlp_working_path_mode = 'ra' " search for nearest ancestor like .git, .hg, and the directory of the current file
let g:ctrlp_swDtch_buffer = 'ET'  " Переходим в файл если он уже открыт в любом окне
let g:ctrlp_use_caching = 1    " включаем cache
let g:ctrlp_clear_cache_on_exit = 0    " Не чистим cache после выхода из vim-а
let g:ctrlp_show_hidden = 1    " показываем скрытые (dotfiles) файлы
let g:ctrlp_mruf_max = 250     " number of recently opened files
"let g:ctrlp_cache_dir = $HOME.'/.cache/ctrlp'
"let g:ctrlp_user_command = 'find %s -type f'
nnoremap <c-l> :CtrlPLine<CR>
nnoremap <LEADER>u :CtrlPUndo<CR>
" TODO: add javascript and some other languages who doesn't have ctags support
" coffee: https://gist.github.com/michaelglass/5210282
" go: http://stackoverflow.com/a/8236826/462233
" objc:  http://www.gregsexton.org/2011/04/objective-c-exuberant-ctags-regex/
" rust: https://github.com/mozilla/rust/blob/master/src/etc/ctags.rust
let g:ctrlp_buftag_types = {
            \ 'go'         : '--language-force=go --golang-types=ftv',
            \ 'coffee'     : '--language-force=coffee --coffee-types=cmfvf',
            \ 'markdown'   : '--language-force=markdown --markdown-types=hik',
            \ 'objc'       : '--language-force=objc --objc-types=mpci',
            \ 'rc'         : '--language-force=rust --rust-types=fTm'
            \ }
"  Bundle 'kien/ctrlp.vim' >-----

"  Bundle 'scrooloose/syntastic'
let g:syntastic_auto_loc_list = 1   " Открываем и закрываем список с ошибками автоматически.
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_enable_signs = 1    " красные метки на линиях
let g:syntastic_error_symbol='✗'
let g:syntastic_warning_symbol='⚠'
let g:syntastic_auto_jump=0         " Не перескакиваем на ошибку автоматически
let g:syntastic_javascript_checkers=["eslint"]
let g:syntastic_html_checkers=[]
let g:syntastic_dart_analyzer_conf='-out /tmp/'
let g:syntastic_dart_dartanalyzer_args = "--strong"

" Если находимся внутри 'quickfix'
" тогда вызываем lclose иначе quit
function! QuitOrLclose(bang)
    if &buftype == 'quickfix'
        let g:syntastic_auto_loc_list = 0
        ccl
        lcl
        let g:syntastic_auto_loc_list = 1
    else
        if a:bang
            quit!
        else
            quit
        endif
    endif
endfunction
com! -nargs=? -bang Q call QuitOrLclose('!' == '<bang>')
cabbrev q Q

" return full path with the trailing slash
"  or an empty string if we're not in an npm project
fun! s:GetNodeModulesAbsPath ()
    let lcd_saved = fnameescape(getcwd())
    silent! exec "lcd" expand('%:p:h')
    let path = finddir('node_modules', '.;')
    exec "lcd" lcd_saved

    " fnamemodify will return full path with trailing slash;
    " if no node_modules found, we're safe
    return path is '' ? '' : fnamemodify(path, ':p')
endfun

fun! s:GetEslintExec (node_modules)
    let eslint_guess = a:node_modules is '' ? '' : a:node_modules . '.bin/eslint'
    return exepath(eslint_guess)
endfun

fun! s:LetEslintExec (eslint_exec)
    if a:eslint_exec isnot ''
        let b:syntastic_javascript_eslint_exec = a:eslint_exec
    endif
endfun

fun! s:UpdateEslintExec ()
    let node_modules = s:GetNodeModulesAbsPath()
    let eslint_exec = s:GetEslintExec(node_modules)
    call s:LetEslintExec(eslint_exec)
endfun

" User project jshintrc if exist when run vim
function! s:find_jshintrc(dir)
    let l:found = globpath(a:dir, '.jshintrc')
    if filereadable(l:found)
        return l:found
    endif

    let l:parent = fnamemodify(a:dir, ':h')
    if l:parent != a:dir
        return s:find_jshintrc(l:parent)
    endif

    return "~/.jshintrc"
endfunction

function! UpdateJsHintConf()
    let l:dir = expand('%:p:h')
    let l:jshintrc = s:find_jshintrc(l:dir)

    if filereadable(l:jshintrc)
        let g:syntastic_javascript_jshint_args = '--config '.expand(l:jshintrc)
    endif
endfunction

let s:projectDir = fnameescape(getcwd())

fun! s:AddNodeModuleToPath ()
    let old_path = &path
    let node_modules = s:GetNodeModulesAbsPath()
    execute "set path=."
    execute "set path+=".s:projectDir
    execute "set path+=".node_modules
endfun

function! HasConfig(file, dir)
    return findfile(a:file, escape(a:dir, ' ') . ';') !=# ''
endfunction

augroup plugin_syntastic
    autocmd!
    autocmd BufEnter *.js call s:UpdateEslintExec()
    autocmd BufEnter *.js call s:AddNodeModuleToPath()
    autocmd BufNewFile,BufReadPre *.js  let b:syntastic_checkers = ['eslint']
augroup END

"  Bundle 'Lokaltog/vim-easymotion' <-----
let g:EasyMotion_leader_key = "<space>"
"  Bundle 'Lokaltog/vim-easymotion' >-----
"
"  Bundle 'command-t' <-----
nnoremap <leader>, :CommandT<cr>
let g:CommandTFileScanner="git"
"  Bundle 'command-t' >-----

"  Bundle 'benmills/vimux' <-----
nnoremap <Leader>vp :VimuxPromptCommand<CR>
nnoremap <Leader>vpl :VimuxRunLastCommand<CR>
"  Bundle 'benmills/vimux' >-----

"  Bundle 'tpope/vim-dispatch' <-----
nnoremap <Leader>vs :Start<space>
"  Bundle 'tpope/vim-dispatch' >-----

" Bundle 'mileszs/ack.vim' <-----
" Ack заменяем команду с ack на ack-grep
if executable('ack-grep')
    let g:ackprg="ack-grep -H --nocolor --nogroup --column"
    set grepprg=ack-grep\ -a
else
    let g:ackprg="grep"
endif

" Bundle 'mileszs/ack.vim' >-----

" Bundle 'LycosaExplorer' <-----
nnoremap <S-b> :LycosaBufferExplorer<cr>
set hidden
" Bundle 'LycosaExplorer' >-----

" Bundle 'Lokaltog/vim-powerline' <-----
set encoding=utf-8
" Bundle 'Lokaltog/vim-powerline' >-----

" Bundle 'maksimr/vim-jsbeautify' <-----
augroup plugin_vim_jsbeautify
    autocmd!

    autocmd FileType javascript nnoremap <buffer>  <c-f> :call JsxBeautify()<cr>
    autocmd BufEnter *.jsx nnoremap <buffer>  <c-f> :call JsxBeautify()<cr>
    autocmd BufEnter *.json nnoremap <buffer>  <c-f> :call JsonBeautify()<cr>
    autocmd FileType html nnoremap <buffer> <c-f> :call HtmlBeautify()<cr>
    autocmd FileType css nnoremap <buffer> <c-f> :call CSSBeautify()<cr>

    autocmd FileType javascript vnoremap <buffer>  <c-f> :call RangeJsBeautify()<cr>
    autocmd BufEnter *.jsx vnoremap <buffer>  <c-f> :call RangeJsxBeautify()<cr>
    autocmd BufEnter *.json vnoremap <buffer>  <c-f> :call RangeJsonBeautify()<cr>
    autocmd FileType html vnoremap <buffer> <c-f> :call RangeHtmlBeautify()<cr>
    autocmd FileType css vnoremap <buffer> <c-f> :call RangeCSSBeautify()<cr>
augroup END
" Bundle 'maksimr/vim-jsbeautify' >-----


" Bundle 'maksimr/vim-translator' <-----
" Настройка переводчика
" Устанавливаем язык для переводчика (vim-gtranslate)
" Устанавливаем кнопку для перевода в визуальном режиме (vim-gtranslate)
let g:goog_user_conf = {'langpair' : 'en|ru', 'v_key': 'T', 'cmd': 'node'}
nnoremap g; :Translate<space>
" Bundle 'maksimr/vim-translator' >-----

" Bundle 'thisivan/vim-bufexplorer' <----
" открывает окно с текущей директорией
nnoremap <C-e> :Explore<cr>
nnoremap <S-e> :BufExplorer<cr>
" Bundle 'thisivan/vim-bufexplorer' >----

" Bundle 'mattn/emmet-vim' <-----
let g:user_zen_settings = { 'php' : { 'extends' : 'html', 'filters' : 'c', }, 'xml' : { 'extends' : 'html', }, 'haml' : { 'extends' : 'html', 'filters' : 'haml' } }
let g:user_zen_leader_key = '<c-y>' " Устанавливаем основную комбинацию клавиш (zencoding-vim)
" Bundle 'mattn/emmet-vim' >-----

" Bundle 'xolox/vim-session' <-----
let g:session_autosave = 'yes'
let g:session_autoload = 'yes'
let g:session_default_to_last = 1

nnoremap <Leader>ss :SaveSession<space>
nnoremap <Leader>sd :DeleteSession<space>
nnoremap <Leader>so :OpenSession<space>
nnoremap <Leader>sc :CloseSession<Enter>
" Bundle 'xolox/vim-session' >-----

" Bundle 'Raimondi/delimitMate' <-----
let g:delimitMate_expand_cr = 1 " create line break when pressing enter
let g:delimitMate_expand_space = 1
" Bundle 'Raimondi/delimitMate' >-----

" Bundle 'marijnh/tern_for_vim' <-----
augroup plugin_tern_for_vim
    autocmd!

    autocmd FileType javascript noremap <buffer>  <LocalLeader>tp :TernDef<cr>
    autocmd FileType javascript noremap <buffer>  <LocalLeader>tr :TernRefs<cr>
    autocmd FileType javascript noremap <buffer>  <LocalLeader>tpp :TernDefPreview<cr>
    autocmd FileType javascript noremap <buffer>  <LocalLeader>trr :TernRename<cr>
    autocmd FileType javascript noremap <buffer>  <LocalLeader>tt :TernType<cr>
augroup END
" Bundle 'marijnh/tern_for_vim' >-----

" Bundle 'xolox/vim-notes' <-----
let g:notes_directories = ['~/Documents/Notes']
" Bundle 'xolox/vim-notes' >-----

" Bundle 'takac/vim-hardtime' <-----
let g:hardtime_default_on = 0
" Bundle 'takac/vim-hardtime' >-----

" Bundle 'tpope/vim-fugitive' <-----
nnoremap <Leader>gs :Gstatus<CR>
nnoremap <Leader>gd :Gdiff<CR>
nnoremap <Leader>gc :Gcommit
nnoremap <Leader>gb :Git blame<CR>
nnoremap <Leader>gl :Glog<CR>
nnoremap <Leader>gp :Git push<CR>

command! -nargs=+ GitGrep execute 'let &grepprg="git grep --no-color" | silent grep! '.<q-args>.' | redraw! | set grepprg& | copen'
nnoremap <Leader>gg :GitGrep <c-r>=expand("<cword>")<cr>
" Bundle 'tpope/vim-fugitive' >-----


" Clojure <-----
"
" How install lein-swank(for lein2.0):
"     You should put lein-swank plugin version `1.4.5` or above
"     to you profiles.clj(./lein/profiles.clj) and run `lein`:
"     {:user {:plugins [ [lein-swank '1.4.5'] ]}}
let g:slimv_swank_clojure = '!lein swank &'
let g:slimv_leader = '\'
let g:vimrcps_loaded = 1
" Clojure >-----

" tpope/vim-projectionist <-----
nnoremap <Leader>a :A<cr>
" tpope/vim-projectionist >-----

" airblade/vim-gitgutter <-----
let g:gitgutter_max_signs=5000
" airblade/vim-gitgutter >-----

autocmd BufNewFile,BufRead *.gradle setf groovy


" @description Различное, настройки привязок к клавишам, расширение и т.д.
" @type misc
" 2012-04-22
" Need Refactoring!!! {{{
" spell checker
fun! SpellCheckerToggle()
  if &spell
    set nospell
    iunmap <c-l>
    return
  endif

  set spelllang=ru,en
  set spell
  " По <CTRL-L> заменяем неправильное слово на первое из предложенных
  " в списке suggest
  imap <c-l> <c-g>u<Esc>[s1z=<Esc>gi
endfun

nnoremap <leader>c :call SpellCheckerToggle()<cr>

" set no autoindent
fun! NoAutoIndent()
  :DelimitMateSwitch
  setl noai nocin nosi inde=
endfun

command! NoAutoIndent call NoAutoIndent()
"}}}


" @desc Global Mappings!
" Mapping --- {{{
nnoremap <c-w>" :belowright split %<cr>
" Indentation(formating)
nnoremap <s-f> mngg=G`n
" Поиск и замена слова под курсором
nnoremap \ff :vim /\<<c-r>=expand("<cword>")<cr>\>/ **/*.
nnoremap \s :%s/\<<c-r>=expand("<cword>")<cr>\>/
" Увеличивает и уменьшает ширину окна
" <esc> - ALT, потому что ALT или META клавиши не всегда поддерживаются
nnoremap <esc>. :vertical res +10<cr>
nnoremap <esc>, :vertical res -10<cr>
" tags/ctags/jsctags
" select tag from list
nnoremap <leader>s g]
" go first matched tag
nnoremap <leader>o <C-]>
" открываем .vimrc
nnoremap <leader>ev :vsplit ~/.vimrc<cr>
" загружаем .vimrc в текущую сессию
nnoremap <leader>sv :so ~/.vimrc<cr>
" открывает новую вкладку
nnoremap <leader>nt :tabnew %<cr>

" выход в нормальный режим из insert mode
inoremap jk <esc>

" clipboard (копирование для во внешний буфер, позволяет использовать дальше
" везде не только в виме)
vnoremap <C-c> "+yy

onoremap in( :<c-u>normal! f(vi(<cr>
onoremap ip( :<c-u>normal! F)vi(<cr>
onoremap an( :<c-u>normal! f(va(<cr>
onoremap ap( :<c-u>normal! F)va(<cr>

" <c-r>|<c-p> search in command line
cnoremap <C-r> <Up>
cnoremap <C-p> <Down>
" wildmenu <Left> и <Right> внутри wildmenu перемещают
" курсор, вместо перехода к следующему совпадению
cnoremap <Left> <Space><BS><Left>
cnoremap <Right> <Space><BS><Right>
" }}}


augroup filetype_javascript
    autocmd!
    autocmd FileType javascript noremap <buffer> <LocalLeader>m :Dispatch node %<cr>
    autocmd BufWritePre *.js silent exec "%s/\\s\\+$//e"
augroup END

augroup filetype_ruby
    autocmd!
    autocmd BufRead,BufNewFile *.rb compiler ruby
    autocmd BufRead,BufNewFile *_test.rb,test_*.rb compiler rubyunit
    autocmd FileType ruby noremap <buffer> <F5> :make %<cr>
    autocmd FileType ruby,eruby setlocal omnifunc=rubycomplete
augroup END

augroup filetype_txt
    autocmd!
    autocmd FileType txt setlocal spell
augroup END

augroup filetype_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
augroup END


match Error /\s\+$/

augroup vimrcgroup
    autocmd!
    autocmd BufEnter * silent EditorConfigReload
augroup END

if filereadable(expand("~/.vimlocal"))
  so ~/.vimlocal
endif
