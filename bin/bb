#!/usr/bin/env node

const http = require('http');
const util = require('util');
const fs = require('fs');
const path = require('path');
const argv = minimist()(process.argv.slice(2), {
  '--': true
});
var onKillCallbacks = [];

if (argv.help) {
  printHelp();
  return;
}

switch (argv._[0]) {
  case 'ls':
    ls({
      remote: argv['remote'] || argv['r'],
      count: argv['count']
    });
    break;
  case 'ls-remote':
    ls({
      remote: true,
      count: argv['count']
    });
    break;
  case 'install':
    install(argv._[1]);
    break;
  case 'run':
    run(argv._[1], argv);
    break;
  case 'rm':
    remove(argv._[1]);
    break;
  default:
    printHelp();
}

process.on('SIGTERM', function() {
  onKillCallbacks.forEach((cb) => {
    cb();
  });
  onKillCallbacks = [];
});

process.on('SIGINT', function() {
  onKillCallbacks.forEach((cb) => {
    cb();
  });
  onKillCallbacks = [];
});

function printHelp() {
  br();
  printTitle('Usage');
  printLine('install <build>                                    ', 'Download and install a <build> of YouTrack');
  printLine('remove <build>                                     ', 'Remove a <build>');
  printLine('ls                                                 ', 'List installed builds');
  printLine('ls-remote [--count=10]                             ', 'List remote builds available for install');
  printLine('run <build> [--port | -p] [--host | -h] [--context]', 'Run <build> on [host], [port] and [context]');
  printLine('                                                   ', 'You can specify java parameters after `--`');
  br();

  function printTitle(title) {
    console.log('  ' + title + ':');
  }

  function br() {
    console.log('');
  }

  function printLine(option, description) {
    console.log('    ' + option + '   ' + description);
  }
}


function ls(options) {
  options = options || {};
  const count = options.count || 10;
  const buildTypeId = getBuildTypeId();

  if (options.remote) {
    listLocalBuilds((installedBuilds) => {
      httpGET('/guestAuth/app/rest/buildTypes/' + buildTypeId + '/builds?locator=status:SUCCESS&count=' + count, (response) => {
        response.build.forEach((build) => {
          var isInstalled = installedBuilds.indexOf(build.number) > -1;
          printBuild(build.number, isInstalled);
        });
      });
    });
    return;
  }

  listLocalBuilds((files) => {
    files.forEach((buildNumber) => {
      printBuild(buildNumber, true);
    });
  });
}

function install(buildNumber) {
  const buildTypeId = getBuildTypeId();

  var url = util.format(
    '/guestAuth/app/rest/builds?locator=buildType(id:%s),number:%s',
    buildTypeId,
    buildNumber
  );

  httpGET(url, (response) => {
    const build = response.build[0];
    downloadBuild(build);
  });
}

function run(buildNumber, options) {
  const runPrc = require('child_process').spawn;
  var javaArgs = [
    '-Xmx1g',
    '-XX:PermSize=256m',
    '-XX:MaxPermSize=256m',
    '-Djetbrains.youtrack.disableBrowser=true',
    '-Djetbrains.charisma.suckTheTractorDriversDick=true'
  ];
  const userJavaArgs = options['--'] || [];

  var jarName = 'youtrack-' + buildNumber + '.jar';
  var jarPath = path.resolve(getBuildDir(buildNumber), jarName);

  var host = options['host'] || options['h'] || 'http://127.0.0.1';
  var port = options['port'] || options['p'] || '8088';
  var context = options['context'] || '';
  var baseUrl = host + ':' + port;

  if (options.d || options.dry) {
    javaArgs.push(
      '-Duser.home=' + '/tmp/' + buildNumber + '_' + Date.now()
    );
  }

  if (context) {
    baseUrl += '/' + context;
  }

  var serverArgs = [
    '-Djetbrains.youtrack.baseUrl=' + baseUrl
  ];

  var prc = runPrc('java', []
    .concat(javaArgs)
    .concat(userJavaArgs)
    .concat(serverArgs)
    .concat([
      '-jar',
      jarPath
    ])
    .concat([
      context ? port + '/' + context : port
    ])
  );

  prc.stdout.on('data', (data) => {
    console.log(String(data));
  });

  prc.stderr.on('data', (data) => {
    console.error(String(data));
  });

  prc.on('error', (err) => {
    console.log('run process failed ', err);
  });

  prc.on('close', (code) => {
    console.log('run process exited with code ' + code);
  });
}

function remove(buildNumber) {
  removeBuild(buildNumber, (err) => {
    if (err) {
      console.log('Remove ' + buildNumber + ' failed!');
    } else {
      console.log(buildNumber + ' was removed!');
    }
  });
}

function removeBuild(buildNumber, cb) {
  var exec = require('child_process').exec;
  var buildDir = getBuildDir(buildNumber);

  exec('rm -r ' + buildDir, function(err) {
    if (cb) {
      cb(err);
    }
  });
}

function downloadBuild(build) {
  artifacts(build.id, (response) => {
    const artifact = response.file.filter((file) => {
      return /\.jar$/.test(file.name);
    })[0];

    saveBuildOnTheDisk(build, artifact);
  });
}

function saveBuildOnTheDisk(build, artifact) {
  mkdirp()(getBuildsRootDir());
  const buildDir = getBuildDir(build.number);
  mkdirp()(buildDir, function() {
    var filePath = path.resolve(buildDir, artifact.name);
    var file = createWriteStream(filePath);
    var removeRevertCallback = onKill(() => {
      file.end(() => {
        fs.unlinkSync(filePath);
      });
      removeBuild(build.number);
    });
    downloadArtifact(artifact.href, file, (err) => {
      if (err) {
        console.error('Download ' + build.number + ' failed!!!');
      }
      removeRevertCallback();
    });
  });
}


function downloadArtifact(href, file, cb) {
  var serverInfo = getServerInfo();
  var request = http.get({
    hostname: serverInfo.hostname,
    port: serverInfo.port,
    path: href.replace('metadata', 'content')
  }, (response) => {
    logResponseProgress(response);
    response.pipe(file);
  });

  request.on('end', () => {
    cb();
  });
  request.on('error', (err) => {
    cb(err);
  });
}


function artifacts(buildId, cb) {
  httpGET(util.format(
    '/guestAuth/app/rest/builds/id:%s/artifacts',
    buildId), (response) => {
    cb(response);
  });
}


function getBuildTypeId(TYPE) {
  switch (TYPE) {
    case 'DEV':
      return 'YTDEV_BuildArtifactsJarAndWarGradle';
    case '65':
      return 'YouTrack_65_BuildArtifactsJarAndWarGradleTemplate';
    default:
      return 'YTDEV_BuildArtifactsJarAndWarGradle';
  }
}


function httpGET(path, cb) {
  const serverInfo = getServerInfo();

  return http.get({
    hostname: serverInfo.hostname,
    port: serverInfo.port,
    path: path,
    headers: {
      'Accept': 'application/json'
    }
  }, (res) => {
    var response = '';

    res.on('data', (chunk) => {
      response += chunk;
    });

    res.on('end', () => {
      cb(JSON.parse(response));
    });
  });
}

function getServerInfo() {
  return {
    hostname: 'buildserver.labs.intellij.net',
    port: 80
  };
}

function listLocalBuilds(cb) {
  fs.readdir(getBuildsRootDir(), (_, files) => {
    cb(files || []);
  });
}

function getBuildDir(buildNumber) {
  buildNumber = String(buildNumber);
  return path.resolve(getBuildsRootDir(), buildNumber);
}

function getBuildsRootDir() {
  return path.resolve(getUserHome(), '.youtrack/builds');
}

function getUserHome() {
  return process.env.HOME || process.env.USERPROFILE;
}

function minimist() {
  return function(args, opts) {
    if (!opts) {
      opts = {};
    };

    var flags = {
      bools: {},
      strings: {},
      unknownFn: null
    };

    if (typeof opts['unknown'] === 'function') {
      flags.unknownFn = opts['unknown'];
    }

    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
      flags.allBools = true;
    } else {
      [].concat(opts['boolean']).filter(Boolean).forEach(function(key) {
        flags.bools[key] = true;
      });
    }

    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function(key) {
      aliases[key] = [].concat(opts.alias[key]);
      aliases[key].forEach(function(x) {
        aliases[x] = [key].concat(aliases[key].filter(function(y) {
          return x !== y;
        }));
      });
    });

    [].concat(opts.string).filter(Boolean).forEach(function(key) {
      flags.strings[key] = true;
      if (aliases[key]) {
        flags.strings[aliases[key]] = true;
      }
    });

    var defaults = opts['default'] || {};

    var argv = {
      _: []
    };
    Object.keys(flags.bools).forEach(function(key) {
      setArg(key, defaults[key] === undefined ? false : defaults[key]);
    });

    var notFlags = [];

    if (args.indexOf('--') !== -1) {
      notFlags = args.slice(args.indexOf('--') + 1);
      args = args.slice(0, args.indexOf('--'));
    }

    function argDefined(key, arg) {
      return (flags.allBools && /^--[^=]+$/.test(arg)) ||
        flags.strings[key] || flags.bools[key] || aliases[key];
    }

    function setArg(key, val, arg) {
      if (arg && flags.unknownFn && !argDefined(key, arg)) {
        if (flags.unknownFn(arg) === false) {
          return;
        };
      }

      var value = !flags.strings[key] && isNumber(val) ? Number(val) : val;
      setKey(argv, key.split('.'), value);

      (aliases[key] || []).forEach(function(x) {
        setKey(argv, x.split('.'), value);
      });
    }

    function setKey(obj, keys, value) {
      var o = obj;
      keys.slice(0, -1).forEach(function(key) {
        if (o[key] === undefined) {
          o[key] = {};
        };
        o = o[key];
      });

      var key = keys[keys.length - 1];
      if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
        o[key] = value;
      } else if (Array.isArray(o[key])) {
        o[key].push(value);
      } else {
        o[key] = [o[key], value];
      }
    }

    function aliasIsBoolean(key) {
      return aliases[key].some(function(x) {
        return flags.bools[x];
      });
    }

    for (var i = 0; i < args.length; i++) {
      var arg = args[i];

      if (/^--.+=/.test(arg)) {
        // Using [\s\S] instead of . because js doesn't support the
        // 'dotall' regex modifier. See:
        // http://stackoverflow.com/a/1068308/13216
        var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
        var key = m[1];
        var value = m[2];
        if (flags.bools[key]) {
          value = value !== 'false';
        }
        setArg(key, value, arg);
      } else if (/^--no-.+/.test(arg)) {
        var key = arg.match(/^--no-(.+)/)[1];
        setArg(key, false, arg);
      } else if (/^--.+/.test(arg)) {
        var key = arg.match(/^--(.+)/)[1];
        var next = args[i + 1];
        if (next !== undefined && !/^-/.test(next) && !flags.bools[key] && !flags.allBools && (aliases[key] ? !aliasIsBoolean(key) : true)) {
          setArg(key, next, arg);
          i++;
        } else if (/^(true|false)$/.test(next)) {
          setArg(key, next === 'true', arg);
          i++;
        } else {
          setArg(key, flags.strings[key] ? '' : true, arg);
        }
      } else if (/^-[^-]+/.test(arg)) {
        var letters = arg.slice(1, -1).split('');

        var broken = false;
        for (var j = 0; j < letters.length; j++) {
          var next = arg.slice(j + 2);

          if (next === '-') {
            setArg(letters[j], next, arg);
            continue;
          }

          if (/[A-Za-z]/.test(letters[j]) && /\=/.test(next)) {
            setArg(letters[j], next.split('=')[1], arg);
            broken = true;
            break;
          }

          if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
            setArg(letters[j], next, arg);
            broken = true;
            break;
          }

          if (letters[j + 1] && letters[j + 1].match(/\W/)) {
            setArg(letters[j], arg.slice(j + 2), arg);
            broken = true;
            break;
          } else {
            setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
          }
        }

        var key = arg.slice(-1)[0];
        if (!broken && key !== '-') {
          if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (aliases[key] ? !aliasIsBoolean(key) : true)) {
            setArg(key, args[i + 1], arg);
            i++;
          } else if (args[i + 1] && /true|false/.test(args[i + 1])) {
            setArg(key, args[i + 1] === 'true', arg);
            i++;
          } else {
            setArg(key, flags.strings[key] ? '' : true, arg);
          }
        }
      } else {
        if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
          argv._.push(
            flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
          );
        }
        if (opts.stopEarly) {
          argv._.push.apply(argv._, args.slice(i + 1));
          break;
        }
      }
    }

    Object.keys(defaults).forEach(function(key) {
      if (!hasKey(argv, key.split('.'))) {
        setKey(argv, key.split('.'), defaults[key]);

        (aliases[key] || []).forEach(function(x) {
          setKey(argv, x.split('.'), defaults[key]);
        });
      }
    });

    if (opts['--']) {
      argv['--'] = new Array();
      notFlags.forEach(function(key) {
        argv['--'].push(key);
      });
    } else {
      notFlags.forEach(function(key) {
        argv._.push(key);
      });
    }

    return argv;
  };

  function hasKey(obj, keys) {
    var o = obj;
    keys.slice(0, -1).forEach(function(key) {
      o = (o[key] || {});
    });

    var key = keys[keys.length - 1];
    return key in o;
  }

  function isNumber(x) {
    if (typeof x === 'number') {
      return true;
    }
    if (/^0x[0-9a-f]+$/i.test(x)) {
      return true;
    }
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
  }
}

function mkdirp() {
  /*eslint-disable */
  var path = require('path');
  var fs = require('fs');
  var _0777 = parseInt('0777', 8);

  function mkdirP(p, opts, f, made) {
    if (typeof opts === 'function') {
      f = opts;
      opts = {};
    } else if (!opts || typeof opts !== 'object') {
      opts = {
        mode: opts
      };
    }

    var mode = opts.mode;
    var xfs = opts.fs || fs;

    if (mode === undefined) {
      mode = _0777 & (~process.umask());
    }
    if (!made) made = null;

    var cb = f || function() {};
    p = path.resolve(p);

    xfs.mkdir(p, mode, function(er) {
      if (!er) {
        made = made || p;
        return cb(null, made);
      }
      switch (er.code) {
        case 'ENOENT':
          mkdirP(path.dirname(p), opts, function(er, made) {
            if (er) cb(er, made);
            else mkdirP(p, opts, cb, made);
          });
          break;

          // In the case of any other error, just see if there's a dir
          // there already.  If so, then hooray!  If not, then something
          // is borked.
        default:
          xfs.stat(p, function(er2, stat) {
            // if the stat fails, then that's super weird.
            // let the original error be the failure reason.
            if (er2 || !stat.isDirectory()) cb(er, made)
            else cb(null, made);
          });
          break;
      }
    });
  }

  mkdirP.sync = function sync(p, opts, made) {
    if (!opts || typeof opts !== 'object') {
      opts = {
        mode: opts
      };
    }

    var mode = opts.mode;
    var xfs = opts.fs || fs;

    if (mode === undefined) {
      mode = _0777 & (~process.umask());
    }
    if (!made) made = null;

    p = path.resolve(p);

    try {
      xfs.mkdirSync(p, mode);
      made = made || p;
    } catch (err0) {
      switch (err0.code) {
        case 'ENOENT':
          made = sync(path.dirname(p), opts, made);
          sync(p, opts, made);
          break;

          // In the case of any other error, just see if there's a dir
          // there already.  If so, then hooray!  If not, then something
          // is borked.
        default:
          var stat;
          try {
            stat = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat.isDirectory()) throw err0;
          break;
      }
    }

    return made;
  };

  mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
  return mkdirP;
  /*eslint-enable */
}

function logResponseProgress(response) {
  var len = parseInt(response.headers['content-length'], 10);
  var cur = 0;
  var total = len / 1048576; //1048576 - bytes in  1Megabyte
  var loaderTick = loader(35, 5);

  var printMessage = function() {
    var percents = (100.0 * cur / len).toFixed(2) + '%';
    var curMb = (cur / 1048576).toFixed(2) + 'mb';
    var totalMb = total.toFixed(2) + 'mb';

    var message = ' ' + percents + ' [' + curMb + '/' + totalMb + ']';

    loaderTick(null, message);
  };

  var timeoutDelay = 500;
  var timeout = setTimeout(function timeoutTick() {
    printMessage();
    timeout = setTimeout(timeoutTick, timeoutDelay);
  }, timeoutDelay);

  var removeCacnelTimeout = onKill(() => {
    if (timeout) {
      clearTimeout(timeout);
    }
  });

  response.on('data', function(chunk) {
    cur += chunk.length;
  });

  response.on('end', function() {
    removeCacnelTimeout();
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
    console.log('Downloading complete');
  });
}

function createWriteStream(filePath) {
  return fs.createWriteStream(filePath);
}

function printBuild(buildNumber, isInstalled) {
  var marker = isInstalled ? '◉' : '◯';
  console.log(' ' + marker + ' ' + buildNumber);
}

function onKill(cb) {
  onKillCallbacks.push(cb);
  return () => {
    onKillCallbacks = onKillCallbacks.filter((_cb) => {
      return _cb !== cb;
    });
  };
}

function loader(length, spliterChar) {
  var readline = require('readline');
  var dots = Array(length || 10).join('.,').split(',');
  var shift = dots.length;
  var spliter = (typeof spliterChar === 'string') ? spliterChar : Array(spliterChar || 2).join(' ');

  return (beforeMessage, afterMessage) => {
    beforeMessage = beforeMessage || '';
    afterMessage = afterMessage || '';

    var message = '';

    if (beforeMessage) {
      message += beforeMessage + ' ';
    }

    var printDots = dots.concat([]);
    var printSpliter = '' + spliter;
    var setIndex = 0;

    if (shift < spliter.length) {
      printSpliter = printSpliter.substr(0, shift);
      setIndex = 0;
    } else if ((shift + spliter.length) > dots.length) {
      printSpliter = printSpliter.substr(0, ((dots.length + 1) - shift));
      setIndex = shift - printSpliter.length;
    } else {
      setIndex = shift - printSpliter.length;
    }

    if (printSpliter.length) {
      printDots.splice(0, printSpliter.length);
      printDots[setIndex] = printSpliter;
    }

    if (shift >= dots.length) {
      shift = 0;
    } else {
      shift += 1;
    }

    message += printDots.join('');

    if (afterMessage) {
      message += ' ' + afterMessage;
    }

    readline.cursorTo(process.stdout, 0);
    process.stdout.clearLine();
    process.stdout.write(message);
  };
}
